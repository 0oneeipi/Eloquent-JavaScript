:chap_num: 15
:prev_link: 14_event
:next_link: 16_FIXME
:load_files: ["js/15_game.js", "js/code/game_levels.js"]

= Practical: A Game =

My initial fascination with computers, like that of many kids,
originated with computer games. I was drawn in by the tiny
computer-simulated worlds which I could manipulate and impact (sort
of). More, I suppose, because of the way I could project my
imagination into them, than because of the possibilities they actually
offered.

I wouldn't wish a career in game programming on anyone—much like in
the music industry, the discrepancy between the many eager young
people wanting to work in it and the actual demand for such people
creates a rather unhealthy atmosphere. But writing games for fun can
be very rewarding. A game world, even when simple, is still a world.
Who doesn't like creating worlds?

This chapter will walk through the implementation of a simple platform
game. Platform games (or “jump and run” games) are games that involve
moving a figure through an (often two-dimensional, side-view) world,
and jumping onto and over things.

== The game ==

Our game will be roughly based on “http://www.lessmilk.com/10[Dark
Blue]”!!tex (http://www.lessmilk.com/10)!! by Thomas Palef. I chose
this game because it is extremely minimal (and thus implementable
without _too_ much code), yet entertaining. It looks like this:

image::img/darkblue.png[alt="The game Dark Blue"]

// FIXME Make this explanation work for the grayscale paper book

The dark box represents the player, whose task it is to collect the
yellow boxes (coins) while avoiding the red stuff (lava?). A level is
completed when all coins have been collected.

The player can walk around with the left and right arrow keys, and
jump with the up arrow. And jumping is something these game
protagonists know how to do, reaching many times their own height,
with ease. They are also able to change direction in mid-air. Though
this may not be entirely realistic, it helps give the player a feeling
of being in direct control of the on-screen avator.

The game's elements consist of a fixed background, laid out like a
grid. Each field on this grid is either empty, solid, or lava.

Overlaid on this background are the moving and changeable elements,
the player, coins, pieces of lava that move. Unlike the artificial
life simulation from Chapter 7, the positions of these elements are
not constrained to the grid—their coordinates may be fractional,
allowing smooth motion (as opposed to jumpy “one field at a time”
motion).

== The technology ==

We will use the browser DOM to display the game, and read user input
by handling key events.

The screen- and keyboard-related code is only a tiny portion of the
work we need to do to implement this game. Since everything looks like
single-color boxes, drawing is uncomplicated: We create DOM elements,
and use styling to give them a background color, size, and position.

We can represent the background, which is a static grid, as a table of
colored cells. The free-moving elements can be overlaid on top of that
using absolutely positioned elements.

In games (and similar programs) that have to respond and animate
without noticeable delay, efficiency is an important concern. Though
the DOM was not originally designed for high-performance graphics, it
is surprisingly effective in that area. We saw some simple animations
in Chapter 13. On a modern machine, drawing a simple game like this
one will not require us to worry about performance.

In the next chapte, we will explore another browser technology, the
`<canvas>` tag, which provides a way to draw graphics that is more
similar to traditional graphics interfaces—working in terms of shapes
and pixels, rather than DOM nodes.

== Levels ==

In Chapter 7 we used arrays of strings to describe a two-dimensional
grid. That approach is useful here as well. It will allow us to easily
design levels without first building a level editor.

This, for example, could specify a simple level:

// include_code

[source,javascript]
----
var simpleLevelPlan = [
  "                      ",
  "  x         o o  = x  ",
  "  x @      xxxxx   x  ",
  "  xxxxx            x  ",
  "      x!!!!!!!!!!!!x  ",
  "      xxxxxxxxxxxxxx  ",
  "                      "
];
----

Both the fixed grid and the moving elements are included in the
strings. We use “x” characters for walls, spaces for empty space, and
exclamation marks for fixed, non-moving lava tiles.

The initial player position is indicated by an “@” character. Coins
will be put wherever there is an “o”, and the equals sign (“=”)
indicates a block of lava that moves back and forth horizontally. Note
that the grid for these positions will be set to contain empty space,
and an additional data structure will be used to track the position of
these non-fixed elements.

We will also support “|” for vertically moving lava, and “v” for
“dripping” lava—vertically moving blocks of lava that don't bounce
back and forth, but move down and jump back to their start position
when they hit the floor.

A whole game will be represented by an array of level arrays, though
which the player must progress one after the other, by collecting all
the coins in each. When the player touches lava, the current level is
simple restored to its starting position, and they can try again.

== Reading a level ==

The following constructor, given an array of strings as seen above,
constructs a level object.

// include_code

[source,javascript]
----
function Level(plan) {
  this.width = plan[0].length;
  this.height = plan.length;
  this.grid = [];
  this.actors = [];

  for (var y = 0; y < this.height; y++) {
    var line = plan[y], gridLine = [];
    for (var x = 0; x < this.width; x++) {
      var ch = line[x], fieldType = null;
      var Actor = actorChars[ch];
      if (Actor)
        this.actors.push(new Actor(new Vector(x, y), ch));
      else if (ch == "x")
        fieldType = "wall";
      else if (ch == "!")
        fieldType = "lava";
      gridLine.push(fieldType);
    }
    this.grid.push(gridLine);
  }

  this.player = this.actors.filter(function(actor) {
    return actor.type == "player";
  })[0];
  this.finished = this.finishDelay = null;
}
----

A level stores its width and height, along with two arrays—one for the
grid, and one for the “actors”, the dynamic elements. The grid is
represented as an array of arrays, where each of the inner arrays
represents a horizontal line of the grid, and holds either null, for
empty squares, or a string indicating the type of the square—either
`"wall"` or `"lava"`.

The actors array holds a number of objects that track the current
position of the dynamic elements in the level. Each of these is
expected to have a `pos` property giving its position (the coordinates
of its top left corner), a `size` property giving its size, and a
`type` property that holds a string that identifies the element
(“lava”, “coin”, or “player”).

After building up the grid, we use the `filter` method to find the
player actor object, and store it in a property of the level. The
`finished` and `finishDelay` properties will be used when the player
dies or wins, to show a simple animation rather than immediately
resetting or advancing the level (which would look silly).

For brevity, this code assumes that level plans are well-formed—that
each line has the same length and only contains allowed characters,
and that there is a single player start position in it.

== Actors ==

To represent the position and size of an actor, we will return to our
trusty `Point` type, which groups an x and y coordinate into an
object. Only, because sizes are not really points, and we will also
use this to represent speeds, we will call it `Vector` instead (in the
mathematical sense).

// include_code

[source,javascript]
----
function Vector(x, y) {
  this.x = x; this.y = y;
}
Vector.prototype.plus = function(other) {
  return new Vector(this.x + other.x, this.y + other.y);
};
Vector.prototype.times = function(factor) {
  return new Vector(this.x * factor, this.y * factor);
};
----

The `times` method scales a vector by a given factor, and will be
useful when we need to multiply a speed vector by a time interval.

The `actorChars` was used by the `Level` constructor to associate
characters with constructor functions. It looks like this:

// include_code

[source,javascript]
----
var actorChars = {
  "@": Player,
  "o": Coin,
  "=": Lava, "|": Lava, "v": Lava
};
----

There are three characters mapping to `Lava`. The `Level` constructor
passes the actor the character it was based on as an argument, which
the `Lava` constructor uses to determine its behavior (bouncing
horizontally or vertically, or dripping).

The player type is built with this simple constructor. It has a
property `ySpeed` containing its current vertical speed, which we will
use to simulate momentum and gravity (the horizontal speed will be
entirely based on the arrow keys, without any momentum).

// include_code

[source,javascript]
----
function Player(pos) {
  this.pos = pos.plus(new Vector(0, -0.5));
  this.size = new Vector(0.8, 1.5);
  this.ySpeed = 0;
}
Player.prototype.type = "player";
----

When constructing a dynamic `Lava` object, we need to set up some
state based on the character it was based on. Moving lava will simply
move along at its given speed until it hits an obstacle. At that
point, if it has a `repeatPos` property, it will jump back to its
start position (dripping). If it does not, it will invert its speed
and continue merrily on (bouncing). The constructor only sets up the
necessary properties—the method that does the actual moving will be
written later on.

// include_code

[source,javascript]
----
function Lava(pos, ch) {
  this.pos = pos;
  this.size = new Vector(1, 1);
  if (ch == "=") {
    this.speed = new Vector(2, 0);
  } else if (ch == "|") {
    this.speed = new Vector(0, 2);
  } else if (ch == "v") {
    this.speed = new Vector(0, 3);
    this.repeatPos = pos;
  }
}
Lava.prototype.type = "lava";
----

`Coin` actors are very simple, and mostly sit statically in their
place. But to liven up the game a little, they are given a “wobble”, a
slight vertical motion back and forth. To track this, a coin object
stores both a current position and a base position (around which the
wobble happens), and has a `wobble` property that tracks its current
position.

// include_code

[source,javascript]
----
function Coin(pos) {
  this.basePos = this.pos = pos.plus(new Vector(.2, .1));
  this.size = new Vector(.6, .6);
  this.wobble = Math.random() * Math.PI * 2;
}
Coin.prototype.type = "coin";
----

To prevent all coins moving up and down synchronously, the starting
phase of each coin is randomized. We will be using `Math.sin` (a sine
wave) to model the motion, so we multiply the value returned by
`Math.random` by 2π, which causes it to take a random position on that
wave. If none of this makes sense to you, don't worry, it is not
necessary to understand it to follow the chapter.

We now have all the parts needed to initialize a level.

// include_code strip_log

[source,javascript]
----
var simpleLevel = new Level(simpleLevelPlan);
console.log(simpleLevel.width, "by", simpleLevel.height);
----

== Encapsulation as a burden ==

Most of the code in this chapter will worry very little about
encapsulation. This has two reasons. Firstly, encapsulation takes
extra effort. It will make programs bigger and require additional
concepts and interfaces to be introduced. Since there is only so much
code you can throw at a reader before their eyes glaze over, I've made
an effort to keep the program small.

Secondly, the various elements in this game are so closely tied
together that if the behavior of one of them changed, it is unlikely
that any of the others would be able to stay the same. Interfaces
between the elements would end up encoding a lot of assumptions about
the way the game works. This makes them a lot less effective—whenever
you make a change to one part of the system, you still have to worry
about the way it impacts the other parts, because their interfaces
wouldn't cover the new situation.

Some “cutting points” in a system lend themselves very well to
separation through rigorous interfaces , others don't. Trying to
encapsulate something that isn't a suitable boundary is a sure way to
waste a lot of energy. When you are making this mistake, you'll
usually notice that your interfaces are getting awkwardly large and
detailed, and that they need to be updated a lot to cover new
situations.

There is one thing that we _will_ encapsulate in this chapter, and
that is the drawing subsystem. The reason for this is that we will
display the same game in a different way in the next chapter. By
putting the drawing behind an interface, we can simply load the same
game program there, but plug in a new display module.

== Drawing ==

The encapsulation of the drawing code is done by defining a “display”
object, which displays a given level. The display type we define in
this chapter is called `DOMDisplay`, because is uses simple DOM nodes
to show the level.

We will be using a sheet to set the actual colors and other fixed
properties of the nodes that make up the game. It would also be
possible to directly assign to the nodes' `style` property when we
create them, but that would produce rather ugly programs.

The following helper function provides a short way to create an
element and give it a class.

// include_code

[source,javascript]
----
function element(name, className) {
  var elt = document.createElement(name);
  if (className) elt.className = className;
  return elt;
}
----

A display is created by giving it a parent node to which it should
append itself, and a level object.

// include_code

[source,javascript]
----
function DOMDisplay(parent, level) {
  this.wrap = parent.appendChild(element("div", "game"));
  this.level = level;

  this.wrap.appendChild(this.drawBackground());
  this.actorNode = null;
  this.drawFrame();
}
----

We used the fact that `appendChild` returns the appended node to put the 

The level's background, which never changes, is drawn once. The actors
are redrawn every time the display is updated. The `actorNode`
property will be used by `drawFrame` to track the node that holds the
actors, so that they can be easily removed and replaced.

Our coordinates and sizes are tracked in units relative to the grid
size, where a size or distance of one means one grid unit. When
setting pixel sizes, we will have to scale these coordinates up—things
would be ridiculously small at a single pixel per square. The `scale`
variable gives the amount of pixels a single unit takes up on the
screen.

// include_code

[source,javascript]
----
var scale = 20;

DOMDisplay.prototype.drawBackground = function() {
  var table = element("table", "background");
  table.style.width = this.level.width * scale + "px";
  this.level.grid.forEach(function(row) {
    var rowElt = table.appendChild(element("tr"));
    rowElt.style.height = scale + "px";
    row.forEach(function(type) {
      rowElt.appendChild(element("td", type));
    });
  });
  return table;
};
----

As mentioned earlier, the background is drawn as a `<table>` element.
This nicely corresponds to the structure of the `grid` property in the
level—each row of the grid is turned into a table row (`<tr>`
element). The strings in the grid are used as class names for the
table cell (`<td>`) elements. The following CSS helps the resulting
table look like the background we want:

[source,text/css]
----
.background    { background: #34a6fb;
                 table-layout: fixed;
                 border-spacing: 0; }
.background td { padding: 0; }
.lava          { background: #ff6363; }
.wall          { background: white; }
----

Some of these (`table-layout`, `border-spacing`, and `padding`) are
simply used to suppress unwanted default behavior. We don't want space
between the table cells, or padding inside them, and we set the
table's algorithm for computing the width of its columns to a simple,
predictable variant (the way tables are laid out, in HTML, is a very
complicated thing).

The `background` rules set background colors. CSS allows colors to be
specified both as words (`white`) and with a rather cryptic `#RRGGBB`
format, where the hash is followed by pairs of hexadecimal (base-16)
digits giving first the red, then the green, and then the blue
components of the color, given as numbers between zero and `ff` (255).
So in `#34a6fb` the the red component is hexadecimal `34` (3 × 16 + 4
equals decimal 52), green is `a6` (10 × 16 + 6 = 166), and blue `fb`
(15 × 16 + 11 = 251). Since the blue component is the largest, the
resulting color will be blueish. You can see that in the `.lava` rule,
the first part of the number (red) is the largest.

Drawing the actors is quite straightforward:

// include_code

[source,javascript]
----
DOMDisplay.prototype.drawActors = function() {
  var wrap = element("div", "actors");
  this.level.actors.forEach(function(actor) {
    var elt = wrap.appendChild(element("div", "actor " + actor.type));
    elt.style.width = actor.size.x * scale + "px";
    elt.style.height = actor.size.y * scale + "px";
    elt.style.left = actor.pos.x * scale + "px";
    elt.style.top = actor.pos.y * scale + "px";
  });
  return wrap;
}
----

Each actor gets an element, and we set the element's position and size
based on the actor's properties, multiplying each value by the display
`scale`. We ensure that the wrapping `<div>` element has a relative
position style, so that the actors can be positioned relative to its
top left corner.

This is the relevant CSS code (lava actors will use the same CSS class
as lava grid squares):

[source,text/css]
----
.actors { position: relative; }
.actor  { position: absolute; }
.coin   { background: #f1e559; }
.player { background: #404040; }
----

To update the display when the world changes, the `drawFrame` method
removes the old actor graphics, if any, and redraws them in their new
positions. It may be tempting to try and reuse the DOM nodes, but that
would cause unneccesary interdependency between the level code and the
drawing code—we'd need to have a way to associate actors with nodes,
and the drawing code must know when to remove nodes when their actors
vanish. For a simple game like this, redrawing is fast enough.

// include_code

[source,javascript]
----
DOMDisplay.prototype.drawFrame = function() {
  if (this.actorNode)
    this.wrap.removeChild(this.actorNode);
  this.actorNode = this.wrap.appendChild(this.drawActors());
  this.scrollPlayerIntoView();
};
----

We don't assume that levels fit into the viewport. That is why the
`scrollPlayerIntoView` call is needed—it ensures that, if the level is
sticking out outside of the viewport, we scroll that viewport to make
sure the player is near its center. The following CSS gives the game's
wrapping DOM node a maximum size, and ensures that anything that
sticks out is not displayed:

[source,text/css]
----
.game {
  overflow: hidden;
  max-width:  600px;
  max-height: 600px;
}
----

In the `scrollPlayerIntoView` method, we find the player's position,
and update the wrapping node's scroll position, by manipulating it's
`scrollLeft` and `scrollTop` properties, when the player is too close
to the edge.

// include_code

[source,javascript]
----
DOMDisplay.prototype.scrollPlayerIntoView = function() {
  var width = this.wrap.clientWidth;
  var height = this.wrap.clientHeight;
  var margin = width / 3;

  // The viewport
  var left = this.wrap.scrollLeft, right = left + width;
  var top = this.wrap.scrollTop, bottom = top + height;

  var p = this.level.player;
  var center = p.pos.plus(p.size.times(0.5)).times(scale);

  if (center.x < left + margin)
    this.wrap.scrollLeft = center.x - margin;
  else if (center.x > right - margin)
    this.wrap.scrollLeft = center.x + margin - height;
  if (center.y < top + margin)
    this.wrap.scrollTop = center.y - margin;
  else if (center.y > bottom - margin)
    this.wrap.scrollTop = center.y + margin - height;
};
----

The way the player's center is found shows how the methods on our
`Vector` type allow rather natural-looking computations to be done
with objects. To find the center, we add the player's position (its
top left corner) and half its size. That is the center in level
coordinates, but we need it in pixel coordinates, so we then multiply
the resulting vector by our display scale.

Next, a series of checks verify that the player position isn't outside
of the allowed range. Note that sometimes this will set nonsense
scroll coordinates, below zero or beyond the element's scrollable
area. This is okay—the DOM will constrain them to sane values. Setting
`scrollLeft` to -10 will cause it to become zero.

It would have been slightly simpler to always try to scroll the player
to the center of the viewport. But this creates a rather jarring
effect. As you are jumping, the view will constantly shift up and
down. Having it move up as you jump close to the edge, and then stay
there, is more pleasant.

We should now be able to display our tiny level:

[source,text/html]
----
<link rel="stylesheet" href="css/game.css">

<script>
  var simpleLevel = new Level(simpleLevelPlan);
  var display = new DOMDisplay(document.body, simpleLevel);
</script>
----

The `<link>` tag, when used with `rel="stylesheet"`, is a way to load
a CSS file into a page. In this case, `game.css` contains the styles
necessary for our game.

// include_code

[source,javascript]
----
DOMDisplay.prototype.cleanup = function() {
  this.wrap.parentNode.removeChild(this.wrap);
};
----




// include_code

[source,javascript]
----
var maxStep = .05;
Level.prototype.process = function(dt, keys) {
  if (this.finished) {
    this.finishDelay -= dt;
    if (this.finishDelay <= 0)
      return this.finished;
    keys = Object.create(null);
  }
  while (dt > 0) {
    for (var i = 0; i < this.actors.length; i++)
      this.actors[i].act(Math.min(dt, maxStep), this, keys);
    dt -= maxStep;
  }
};

Level.prototype.obstacleAt = function(pos, size) {
  var yStart = Math.floor(pos.y), yEnd = Math.ceil(pos.y + size.y);
  var xStart = Math.floor(pos.x), xEnd = Math.ceil(pos.x + size.x);
  if (xStart < 0 || xEnd > this.width || yStart < 0)
    return "wall";
  if (yEnd > this.height)
    return "lava";
  for (var y = yStart; y < yEnd; y++) {
    for (var x = xStart; x < xEnd; x++) {
      var fieldType = this.grid[y][x];
      if (fieldType) return fieldType;
    }
  }
};

Level.prototype.actorAt = function(actor) {
  for (var i = 0; i < this.actors.length; i++) {
    var other = this.actors[i];
    if (other != actor &&
        actor.pos.x + actor.size.x > other.pos.x &&
        actor.pos.x < other.pos.x + other.size.x &&
        actor.pos.y + actor.size.y > other.pos.y &&
        actor.pos.y < other.pos.y + other.size.y)
      return other;
  }
};

Level.prototype.playerHit = function(type, actor) {
  if (type == "lava" && !this.finished) {
    this.finished = "lost";
    this.finishDelay = 1;
  } else if (type == "coin") {
    this.actors.splice(this.actors.indexOf(actor), 1);
    if (!this.actors.some(function(actor) {
      return actor.type == "coin";
    })) {
      this.finished = "won";
      this.finishDelay = 1;
    }
  }
};

// Actors



Player.prototype.act = function(dt, level, keys) {
  this.moveH(level, dt, keys);
  this.moveV(level, dt, keys);

  var other = level.actorAt(this);
  if (other) level.playerHit(other.type, other);

  if (level.finished == "won") {
    this.type = "player won";
  } else if (level.finished == "lost") {
    this.type = "player lost";
    this.pos.y += dt;
    this.size.y -= dt;
  }
};

Player.prototype.moveH = function(level, dt, keys) {
  var speed = 0;
  if (keys.left) speed -= 7;
  if (keys.right) speed += 7;

  var newPos = this.pos.plus(new Vector(speed * dt, 0));
  var obstacle = level.obstacleAt(newPos, this.size);
  if (obstacle)
    level.playerHit(obstacle);
  else
    this.pos = newPos;
};

Player.prototype.moveV = function(level, dt, keys) {
  this.ySpeed += dt * 30;
  var newPos = this.pos.plus(new Vector(0, this.ySpeed * dt));
  var obstacle = level.obstacleAt(newPos, this.size);
  if (obstacle) {
    level.playerHit(obstacle);
    if (keys.up && this.ySpeed > 0)
      this.ySpeed = -17;
    else
      this.ySpeed = 0;
  } else {
    this.pos = newPos;
  }
};


Lava.prototype.act = function(dt, level) {
  var newPos = this.pos.plus(this.speed.times(dt));
  if (!level.obstacleAt(newPos, this.size))
    this.pos = newPos;
  else if (this.repeatPos)
    this.pos = this.repeatPos;
  else
    this.speed = this.speed.times(-1);
};


Coin.prototype.act = function(dt) {
  this.wobble += dt * 8;
  this.pos = this.basePos.plus(new Vector(0, Math.sin(this.wobble) * .07));
};

// Game management

function trackKeys(targetNode, codes) {
  var data = Object.create(null);
  for (var code in codes) data[codes[code]] = false;
  function handler(event) {
    if (codes.hasOwnProperty(event.keyCode)) {
      data[codes[event.keyCode]] = event.type == "keydown";
      event.preventDefault();
    }
  }
  targetNode.addEventListener("keydown", handler);
  targetNode.addEventListener("keyup", handler);
  return data;
}

function Game(node, levelData) {
  this.levelNumber = 0;
  this.levelData = levelData;
  this.node = node;

  this.keys = trackKeys(node, {37: "left", 38: "up", 39: "right"});
  this.stopped = true;
  node.addEventListener("keydown", function(e) {
    if (e.keyCode == 27) {
      if (this.stopped) this.start();
      else this.stop();
    }
  }.bind(this));
  this.loadLevel(this.levelNumber);
}

Game.prototype.loadLevel = function(n) {
  this.level = new Level(this.levelData[n]);
  if (this.display) this.display.cleanup();
  this.display = new DOMDisplay(this.node, this.level);
};

Game.prototype.stop = function() {
  this.stopped = true;
};
Game.prototype.start = function() {
  var lastTime = null;
  var frame = function(time) {
    if (lastTime != null) {
      var status = this.level.process(Math.min(time - lastTime, 100) / 1000, this.keys);
      if (status == "lost") {
        this.loadLevel(this.levelNumber);
      } else if (status == "won") {
        if (this.levelNumber == this.levelData.length) {
          this.stop();
        } else {
          ++this.levelNumber;
          this.loadLevel(this.levelNumber);
        }
      }
    }
    lastTime = time;
    this.display.drawFrame(this.level);
    if (!this.stopped) requestAnimationFrame(frame);
  }.bind(this);

  this.stopped = false;
  requestAnimationFrame(frame);
};

// Drawing


----
